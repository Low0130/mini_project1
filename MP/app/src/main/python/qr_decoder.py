"""
QR Code Decoder Module for Visually Impaired Navigation System
==============================================================

Module B: QR Code Reader and Direction Processor
- Reads QR code content and extracts location information from QR codes generated by qr_generator.py.
- Supports QR code format: location_id|qr_orientation|color (e.g., "N_G_LAB_101|0.0|red").
- Integrates with map_building.py for location data and route_guidance.py for navigation.
- Provides location information for visually impaired users via accessible UI (e.g., audio feedback).
- Compatible with qr_detection.py for colored QR code detection (red, green, blue).
"""

import cv2
import numpy as np
from pyzbar.pyzbar import decode, ZBarSymbol
import json
from typing import Tuple, Optional, List, Dict, Any
from dataclasses import dataclass, asdict
from map_building import BuildingMap
import traceback  # <--- THIS IS THE FIX

@dataclass
class QRTarget:
    """
    QR target information from qr_detection.py.
    Contains position, size, distance, angle, color, and corners of detected QR code.
    """
    center_x: int
    center_y: int
    width: int
    height: int
    distance_estimate: float
    angle_from_center: float
    color: str
    corners: List[Tuple[int, int]]

@dataclass
class LocationInfo:
    """
    Complete location information decoded from QR code.
    Stores details about a location, including ID, name, coordinates, and QR orientation.
    Supports dynamic direction updates for navigation.
    """
    location_id: str
    location_name: str
    floor: str
    building: str
    coordinates: Tuple[float, float]
    available_directions: Dict[str, float]
    connections: List[str]
    qr_orientation: float
    description: str
    accessibility_info: str
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert LocationInfo to dictionary for JSON serialization."""
        return asdict(self)
    
    def update_directions(self, directions: Dict[str, float]):
        """
        Update available directions dynamically from route_guidance.py.
        """
        self.available_directions.update(directions)

class QRDecoder:
    """
    QR Code Reader and Direction Processor
    """
    
    def __init__(self):
        """
        Initialize QR decoder with location database from BuildingMap.
        """
        self.current_location: Optional[LocationInfo] = None
        self.last_scanned_qr: Optional[str] = None
        self.location_database: Dict[str, LocationInfo] = {}
        self.min_qr_size = 50
        self.max_read_attempts = 5
        self.confidence_threshold = 0.8
        self.building_map = BuildingMap()
        self._initialize_block_n_database()

    def _initialize_block_n_database(self):
        """
        Initialize location database using BuildingMap data.
        """
        all_locations = self.building_map.bottom_rooms + self.building_map.top_rooms + self.building_map.special_areas
        print(f"Python QRDecoder: Found {len(all_locations)} total locations in map_building.py.")
        for loc in all_locations:
            loc_id = loc['location_id']
            if loc_id in self.building_map.nodes:
                self.location_database[loc_id] = LocationInfo(
                    location_id=loc_id,
                    location_name=loc['name'],
                    floor="Ground",
                    building="Block N",
                    coordinates=self.building_map.nodes[loc_id],
                    available_directions={},
                    connections=[],
                    qr_orientation=loc.get('qr_orientation', 0.0),
                    description=f"{loc['name']} in Block N",
                    accessibility_info=loc.get('accessibility_info', "Accessible")
                )
            else:
                print(f"Python QRDecoder WARNING: Location '{loc_id}' found in room list but NOT in nodes dictionary. It will be ignored.")
        print(f"Python QRDecoder: Database initialized with {len(self.location_database)} valid locations.")

    def decode_qr_content(self, qr_data: str) -> Optional[LocationInfo]:
        """
        Decode QR code content and return corresponding LocationInfo.
        """
        try:
            qr_data = qr_data.strip()
            if qr_data.startswith('{') and qr_data.endswith('}'):
                try:
                    data = json.loads(qr_data)
                    location_id = data.get('location_id')
                    if location_id and location_id in self.location_database:
                        return self.location_database[location_id]
                except json.JSONDecodeError:
                    pass
            if '|' in qr_data:
                try:
                    location_id, qr_orientation, color = qr_data.split('|')
                    if location_id in self.location_database:
                        loc_info = self.location_database[location_id]
                        loc_info.qr_orientation = float(qr_orientation)
                        return loc_info
                except ValueError:
                    pass
            qr_data_lower = qr_data.lower()
            for location in self.location_database.values():
                if location.location_name.lower() == qr_data_lower:
                    return location
            if ':' in qr_data:
                parts = qr_data.split(':')
                if len(parts) >= 3:
                    building, floor, room = parts[0].strip(), parts[1].strip(), parts[2].strip()
                    constructed_id = f"{building}_{floor[0].upper()}_{room}"
                    if constructed_id in self.location_database:
                        return self.location_database[constructed_id]
            for location in self.location_database.values():
                if (qr_data_lower in location.location_name.lower() or 
                    qr_data_lower in location.location_id.lower()):
                    return location
            print(f"Could not decode QR data: '{qr_data}'")
            return None
        except Exception as e:
            print(f"Error decoding QR content: {e}")
            return None

    def enhance_qr_region(self, frame: np.ndarray, corners: List[Tuple[int, int]]) -> List[np.ndarray]:
        """
        Extract and enhance QR code region for better decoding.
        """
        try:
            x_coords = [p[0] for p in corners]
            y_coords = [p[1] for p in corners]
            x_min = max(0, min(x_coords) - 20)
            y_min = max(0, min(y_coords) - 20)
            x_max = min(frame.shape[1], max(x_coords) + 20)
            y_max = min(frame.shape[0], max(y_coords) + 20)
            qr_region = frame[y_min:y_max, x_min:x_max]
            if qr_region.size == 0:
                return []
            if len(qr_region.shape) == 3:
                gray = cv2.cvtColor(qr_region, cv2.COLOR_BGR2GRAY)
            else:
                gray = qr_region.copy()
            processed_images = []
            processed_images.append(gray)
            blurred = cv2.GaussianBlur(gray, (3, 3), 0)
            processed_images.append(blurred)
            equalized = cv2.equalizeHist(gray)
            processed_images.append(equalized)
            clahe = cv2.createCLAHE(clipLimit=3.0, tileGridSize=(8, 8))
            clahe_applied = clahe.apply(gray)
            processed_images.append(clahe_applied)
            _, binary_otsu = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
            processed_images.append(binary_otsu)
            adaptive = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, 
                                            cv2.THRESH_BINARY, 11, 2)
            processed_images.append(adaptive)
            kernel = np.ones((2, 2), np.uint8)
            cleaned = cv2.morphologyEx(binary_otsu, cv2.MORPH_CLOSE, kernel)
            processed_images.append(cleaned)
            if gray.shape[0] < 100 or gray.shape[1] < 100:
                scale = 2.0
                enlarged = cv2.resize(gray, None, fx=scale, fy=scale, interpolation=cv2.INTER_CUBIC)
                processed_images.append(enlarged)
            return processed_images
        except Exception as e:
            print(f"Error enhancing QR region: {e}")
            return []

    def read_qr_code(self, qr_target: QRTarget, frame: np.ndarray) -> Optional[LocationInfo]:
        """
        Read QR code content from the detected target. This version has corrected logic.
        """
        try:
            if qr_target.width < self.min_qr_size or qr_target.height < self.min_qr_size:
                return None

            processed_images = self.enhance_qr_region(frame, qr_target.corners)
            if not processed_images:
                return None

            for i, processed_image in enumerate(processed_images):
                try:
                    decoded_objects = decode(processed_image, symbols=[ZBarSymbol.QRCODE])
                    if decoded_objects:
                        qr_data = decoded_objects[0].data.decode('utf-8')
                        print(f"QR data successfully read (attempt {i+1}): '{qr_data}'")

                        location_info = self.decode_qr_content(qr_data)

                        if location_info:
                            self.current_location = location_info
                            self.last_scanned_qr = qr_data
                            print(f"Successfully matched QR data to location: {location_info.location_name}")
                            return location_info
                        else:
                            print(f"QR data '{qr_data}' was read but did not match any location in the database.")
                            return None

                except Exception as decode_error:
                    print(f"An error occurred during decoding attempt {i+1}: {decode_error}")
                    continue

            print("Failed to read any QR data from the image after all attempts.")
            return None

        except Exception as e:
            print(f"A critical error occurred in read_qr_code: {e}")
            traceback.print_exc()
            return None
        
    def get_available_directions(self) -> List[str]:
        """
        Get list of available directions from current location.
        """
        if not self.current_location:
            return []
        return list(self.current_location.available_directions.keys())

    def get_location_info_text(self) -> str:
        """
        Get formatted location information text for UI display or audio feedback.
        """
        if not self.current_location:
            return "No location information available. Please scan a QR code."
        loc = self.current_location
        info_parts = [
            f"Location: {loc.location_name}",
            f"Building: {loc.building}, Floor: {loc.floor}",
            f"Description: {loc.description}"
        ]
        if loc.accessibility_info:
            info_parts.append(f"Accessibility: {loc.accessibility_info}")
        directions = ", ".join(self.get_available_directions())
        info_parts.append(f"Available directions: {directions}")
        return "\n".join(info_parts)

if __name__ == "__main__":
    """
    Main execution for testing the QR decoder.
    """
    decoder = QRDecoder()
    print(decoder.get_location_info_text())