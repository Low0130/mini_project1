"""
QR Code Decoder Module for Visually Impaired Navigation System
==============================================================

Module B: QR Code Reader and Direction Processor
- Reads QR code content and extracts location information from QR codes generated by qr_generator.py.
- Supports QR code format: location_id|qr_orientation|color (e.g., "N_G_LAB_101|0.0|red").
- Integrates with map_building.py for location data and route_guidance.py for navigation.
- Provides location information for visually impaired users via accessible UI (e.g., audio feedback).
- Compatible with qr_detection.py for colored QR code detection (red, green, blue).
"""

import cv2
import numpy as np
from pyzbar.pyzbar import decode, ZBarSymbol
import json
from typing import Tuple, Optional, List, Dict, Any
from dataclasses import dataclass, asdict
from map_building import BuildingMap

@dataclass
class QRTarget:
    """
    QR target information from qr_detection.py.
    Contains position, size, distance, angle, color, and corners of detected QR code.
    """
    center_x: int
    center_y: int
    width: int
    height: int
    distance_estimate: float
    angle_from_center: float
    color: str
    corners: List[Tuple[int, int]]

@dataclass
class LocationInfo:
    """
    Complete location information decoded from QR code.
    Stores details about a location, including ID, name, coordinates, and QR orientation.
    Supports dynamic direction updates for navigation.
    """
    location_id: str                    # Unique identifier (e.g., "N_G_LAB_101")
    location_name: str                  # Human-readable name (e.g., "Computer Lab 101")
    floor: str                         # Floor designation (e.g., "Ground")
    building: str                      # Building name (e.g., "Block N")
    coordinates: Tuple[float, float]   # (x, y) position on floor map
    available_directions: Dict[str, float]  # direction_name: angle_in_degrees (e.g., {"north": 0.0})
    connections: List[str]             # Connected location IDs (e.g., ["N_G_CORRIDOR_A"])
    qr_orientation: float              # QR code mounting angle (degrees, 0 = north-facing)
    description: str                   # Detailed description of location
    accessibility_info: str            # Accessibility details (e.g., "Wheelchair accessible")
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert LocationInfo to dictionary for JSON serialization."""
        return asdict(self)
    
    def update_directions(self, directions: Dict[str, float]):
        """
        Update available directions dynamically from route_guidance.py.
        
        Args:
            directions: Dictionary of direction names and angles (e.g., {"north": 0.0, "east": 90.0}).
        """
        self.available_directions.update(directions)

class QRDecoder:
    """
    QR Code Reader and Direction Processor
    
    Responsibilities:
    1. Decode QR code content in format location_id|qr_orientation|color.
    2. Map decoded data to location information using BuildingMap from map_building.py.
    3. Support multiple QR code formats (direct ID, JSON, name, custom) for flexibility.
    4. Provide location data to route_guidance.py for navigation path planning.
    5. Handle QR code reading errors and ensure reliable decoding for visually impaired users.
    """
    
    def __init__(self):
        """
        Initialize QR decoder with location database from BuildingMap.
        Sets up parameters for QR code reading and initializes Block N database.
        """
        self.current_location: Optional[LocationInfo] = None  # Current decoded location
        self.last_scanned_qr: Optional[str] = None           # Last QR code data to prevent duplicates
        self.location_database: Dict[str, LocationInfo] = {} # Database of location information
        self.min_qr_size = 50          # Minimum QR size (pixels) for reliable reading
        self.max_read_attempts = 5     # Maximum preprocessing attempts for decoding
        self.confidence_threshold = 0.8 # Confidence threshold for valid QR reads
        self.building_map = BuildingMap()  # Load map data from map_building.py
        self._initialize_block_n_database()  # Populate location database

    def _initialize_block_n_database(self):
        """
        Initialize location database using BuildingMap data.
        Creates LocationInfo objects for each location in Block N (ground floor, top rooms, special areas).
        Directions and connections are left empty for route_guidance.py to populate.
        """
        all_locations = self.building_map.bottom_rooms + self.building_map.top_rooms + self.building_map.special_areas
        for loc in all_locations:
            loc_id = loc['location_id']
            self.location_database[loc_id] = LocationInfo(
                location_id=loc_id,
                location_name=loc['name'],
                floor="Ground",  # Assume ground floor; update if map specifies floors
                building="Block N",
                coordinates=self.building_map.nodes[loc_id],
                available_directions={},  # Populated dynamically by route_guidance.py
                connections=[],          # Populated by route_guidance.py
                qr_orientation=loc.get('qr_orientation', 0.0),  # Default to 0 if not specified
                description=f"{loc['name']} in Block N",
                accessibility_info=loc.get('accessibility_info', "Accessible")
            )

    def decode_qr_content(self, qr_data: str) -> Optional[LocationInfo]:
        """
        Decode QR code content and return corresponding LocationInfo.
        Supports multiple formats for flexibility:
        - Direct location ID (e.g., "N_G_LAB_101|0.0|red")
        - JSON (e.g., '{"location_id": "N_G_LAB_101"}')
        - Location name (e.g., "Computer Lab 101")
        - Custom format (e.g., "BlockN:Ground:101")
        - Partial name/ID match
        
        Args:
            qr_data: Raw QR code data string
            
        Returns:
            LocationInfo object if successfully decoded, None otherwise
        """
        try:
            qr_data = qr_data.strip()
            # Try JSON first
            if qr_data.startswith('{') and qr_data.endswith('}'):
                try:
                    data = json.loads(qr_data)
                    location_id = data.get('location_id')
                    if location_id and location_id in self.location_database:
                        return self.location_database[location_id]
                except json.JSONDecodeError:
                    pass
            # Direct location ID match (supports qr_generator.py format: location_id|qr_orientation|color)
            if '|' in qr_data:
                try:
                    location_id, qr_orientation, color = qr_data.split('|')
                    if location_id in self.location_database:
                        # Update qr_orientation if different
                        loc_info = self.location_database[location_id]
                        loc_info.qr_orientation = float(qr_orientation)
                        return loc_info
                except ValueError:
                    pass
            # Case-insensitive name match
            qr_data_lower = qr_data.lower()
            for location in self.location_database.values():
                if location.location_name.lower() == qr_data_lower:
                    return location
            # Structured format (e.g., "BlockN:Ground:101")
            if ':' in qr_data:
                parts = qr_data.split(':')
                if len(parts) >= 3:
                    building, floor, room = parts[0].strip(), parts[1].strip(), parts[2].strip()
                    constructed_id = f"{building}_{floor[0].upper()}_{room}"
                    if constructed_id in self.location_database:
                        return self.location_database[constructed_id]
            # Partial match
            for location in self.location_database.values():
                if (qr_data_lower in location.location_name.lower() or 
                    qr_data_lower in location.location_id.lower()):
                    return location
            print(f"Could not decode QR data: '{qr_data}'")
            return None
        except Exception as e:
            print(f"Error decoding QR content: {e}")
            return None

    def enhance_qr_region(self, frame: np.ndarray, corners: List[Tuple[int, int]]) -> List[np.ndarray]:
        """
        Extract and enhance QR code region for better decoding.
        Applies multiple image processing techniques to improve readability.
        
        Args:
            frame: Original camera frame
            corners: QR code corner points from qr_detection.py
            
        Returns:
            List of processed image variants for decoding attempts
        """
        try:
            # Calculate bounding box with padding
            x_coords = [p[0] for p in corners]
            y_coords = [p[1] for p in corners]
            x_min = max(0, min(x_coords) - 20)
            y_min = max(0, min(y_coords) - 20)
            x_max = min(frame.shape[1], max(x_coords) + 20)
            y_max = min(frame.shape[0], max(y_coords) + 20)
            qr_region = frame[y_min:y_max, x_min:x_max]
            if qr_region.size == 0:
                print("Empty QR region")
                return []
            # Convert to grayscale
            if len(qr_region.shape) == 3:
                gray = cv2.cvtColor(qr_region, cv2.COLOR_BGR2GRAY)
            else:
                gray = qr_region.copy()
            processed_images = []
            # 1. Original grayscale
            processed_images.append(gray)
            # 2. Gaussian blur to reduce noise
            blurred = cv2.GaussianBlur(gray, (3, 3), 0)
            processed_images.append(blurred)
            # 3. Histogram equalization for better contrast
            equalized = cv2.equalizeHist(gray)
            processed_images.append(equalized)
            # 4. CLAHE (Contrast Limited Adaptive Histogram Equalization)
            clahe = cv2.createCLAHE(clipLimit=3.0, tileGridSize=(8, 8))
            clahe_applied = clahe.apply(gray)
            processed_images.append(clahe_applied)
            # 5. Binary threshold (Otsu's method)
            _, binary_otsu = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
            processed_images.append(binary_otsu)
            # 6. Adaptive threshold
            adaptive = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, 
                                            cv2.THRESH_BINARY, 11, 2)
            processed_images.append(adaptive)
            # 7. Morphological operations to clean up
            kernel = np.ones((2, 2), np.uint8)
            cleaned = cv2.morphologyEx(binary_otsu, cv2.MORPH_CLOSE, kernel)
            processed_images.append(cleaned)
            # 8. Resize for better recognition if too small
            if gray.shape[0] < 100 or gray.shape[1] < 100:
                scale = 2.0
                enlarged = cv2.resize(gray, None, fx=scale, fy=scale, interpolation=cv2.INTER_CUBIC)
                processed_images.append(enlarged)
            return processed_images
        except Exception as e:
            print(f"Error enhancing QR region: {e}")
            return []

    def read_qr_code(self, qr_target: QRTarget, frame: np.ndarray) -> Optional[LocationInfo]:
        """
        Read QR code content from detected target provided by qr_detection.py.
        Supports format from qr_generator.py: location_id|qr_orientation|color.
        
        Args:
            qr_target: QRTarget object from qr_detection.py
            frame: Original camera frame
            
        Returns:
            LocationInfo if successfully read and decoded, None otherwise
        """
        try:
            # Check if QR is large enough for reliable reading
            if qr_target.width < self.min_qr_size or qr_target.height < self.min_qr_size:
                print(f"QR code too small: {qr_target.width}x{qr_target.height}")
                return None
            # Get enhanced QR regions
            processed_images = self.enhance_qr_region(frame, qr_target.corners)
            if not processed_images:
                return None
            # Try to decode with each processed image
            for i, processed in enumerate(processed_images):
                try:
                    decoded_objects = decode(processed, symbols=[ZBarSymbol.QRCODE])
                    for decoded_obj in decoded_objects:
                        qr_data = decoded_obj.data.decode('utf-8')
                        print(f"QR data read (attempt {i+1}): '{qr_data}'")
                        # Avoid re-processing the same QR code
                        if qr_data == self.last_scanned_qr:
                            continue
                        # Decode QR content
                        location_info = self.decode_qr_content(qr_data)
                        if location_info:
                            self.current_location = location_info
                            self.last_scanned_qr = qr_data
                            print(f"Successfully decoded location: {location_info.location_name}")
                            return location_info
                except Exception as decode_error:
                    print(f"Decode attempt {i+1} failed: {decode_error}")
                    continue
            print("Failed to decode QR code after all attempts")
            return None
        except Exception as e:
            print(f"Error reading QR code: {e}")
            return None

    def get_available_directions(self) -> List[str]:
        """
        Get list of available directions from current location.
        
        Returns:
            List of direction names (e.g., ["north", "east"]).
        """
        if not self.current_location:
            return []
        return list(self.current_location.available_directions.keys())

    def get_location_info_text(self) -> str:
        """
        Get formatted location information text for UI display or audio feedback.
        
        Returns:
            String with location details, including name, building, floor, and directions.
        """
        if not self.current_location:
            return "No location information available. Please scan a QR code."
        loc = self.current_location
        info_parts = [
            f"Location: {loc.location_name}",
            f"Building: {loc.building}, Floor: {loc.floor}",
            f"Description: {loc.description}"
        ]
        if loc.accessibility_info:
            info_parts.append(f"Accessibility: {loc.accessibility_info}")
        directions = ", ".join(self.get_available_directions())
        info_parts.append(f"Available directions: {directions}")
        return "\n".join(info_parts)

if __name__ == "__main__":
    """
    Main execution for testing the QR decoder.
    Initializes decoder and prints location information.
    """
    decoder = QRDecoder()
    print(decoder.get_location_info_text())
